#!/usr/bin/env python3

# $PKI_SCRIPT_REALM
# Contains the name of the current PKI realm, set in item.name parameter.
# $PKI_SCRIPT_FQDN
# Contains Fully Qualified Domain Name used as the default domain if the realm does not specify one in it's name.
# $PKI_SCRIPT_SUBJECT
# Contains the Distinguished Name, or subject of the certificate, each element separated by the / character, similar to the format of the openssl req -subj option.
# $PKI_SCRIPT_DOMAINS
# List of apex (root) domains configured for the realm, separated by the / character.
# $PKI_SCRIPT_SUBDOMAINS
# List of subdomains which should be added to each apex domain, each one separated by the / character. The special _wildcard_ name means a wildcard subdomain (*.example.com).
# $PKI_SCRIPT_PRIVATE_KEY
# Absolute path to the private key of the current PKI realm.
# $PKI_SCRIPT_DEFAULT_CRT
# Absolute path to the current PKI realm certificate chain, expected to be used in the application configuration files.
# $PKI_SCRIPT_DEFAULT_KEY
# Absolute path to the current PKI realm private key, expected to be used in the application configuration files.
# $PKI_SCRIPT_DEFAULT_PEM
# Absolute path to the current PKI realm combined private key and certificate chain, expected to be used in the application configuration files.
# $PKI_SCRIPT_STATE
# A list of PKI realm states separated by the , character. You can inspect this variable to determine the current state of the current realm (initialization, activation of new certificates, changed files) and react to it in the script.

import os
import sys
import json
import hvac

## These need to be defined in a template and injected 
VAULT_ROLE='server_certs'
VAULT_CERT_TTL='1d'
VAULT_MOUNT_POINT='pki_int'
VAULT_ADDR='http://127.0.0.1:8200'
VAULT_ROLE_PATH=".role"
VAULT_SECRET_PATH=".secret"

# return a unique list of values from delimitedString
def getDelimitedValues(delimitedString):
   d = dict ()
   domain_list = []

   domain_list = delimitedString.split('/')
   l = len(domain_list)
   for i in range(l) :
      d[domain_list[i]] = 1

   return [*d] # returns a list containing the keys

# build the list of domains without duplicates
# each domain will be joined with each subdomain
def buildDNSEntries(domains, subdomains):
   dnsEntries = dict ()

   for domain in domains:
      for subdomain in subdomains:
         if subdomain == '_wildcard_':
            dnsEntry='*.' + domain
         else:
            dnsEntry=subdomain + '.' + domain

         dnsEntries[dnsEntry] = 1

   return [*dnsEntries]

# authenticate to vault and terminated if unsuccessful
def vaultLogin (role_id_path, secret_path):
   # TODO: read role id and secret from the files

   # authenticate to vault and get an access token
   client = hvac.Client(
      url=VAULT_ADDR,
      token='dev-only-token',
   )

   if client.is_authenticated() == False:
      print ('Failed to authenticate - exiting')
      sys._exit()

   return client

# process fields that are multi-valued '/' separated
subjects = getDelimitedValues(os.environ['PKI_SCRIPT_SUBJECT'])
domains = getDelimitedValues(os.environ['PKI_SCRIPT_DOMAINS'])
subdomains = getDelimitedValues(os.environ['PKI_SCRIPT_SUBDOMAINS'])

certDNSvalues = buildDNSEntries(domains, subdomains)

cert_extra_parms = dict()

if len(certDNSvalues) > 1:
   cert_extra_parms['alt_names'] = ", ".join(certDNSvalues)
cert_extra_parms['format'] = 'pem'
cert_extra_parms['private_key_format'] = 'pem'
cert_extra_parms['ttl'] = VAULT_CERT_TTL

client = vaultLogin(VAULT_ROLE_PATH, VAULT_SECRET_PATH)

cert_response = generate_certificate_response = client.secrets.pki.generate_certificate(
   name=VAULT_ROLE,
   mount_point=VAULT_MOUNT_POINT,
   common_name=", ".join(subjects),
   extra_params=cert_extra_parms
   )

print("certificate: {} ".format(cert_response))

# TODO: write the results to the expected files
